# 新規モジュール追加チェックリスト

このドキュメントは、NazcaAzusawaシステムに新規パズルモジュールを追加する際の確認事項をまとめたものです。

## 📋 システム概要

- **レーン構造**: 3段（top, mid, bot）、各レーンに40個のモジュールが循環配置
- **モジュールID**: `{tier}-{index}` 形式（例: `top-5`, `mid-13`, `bot-6`）
- **無限スクロール**: 各レーンは横スクロールで循環し、モジュールが無限に表示される

## ✅ 追加手順チェックリスト

### 1. モジュール定義の追加 (`js/config.js`)

- [ ] `MODULE_CONFIG` オブジェクトに新規エントリを追加
  - 形式: `"{tier}-{index}": { type: "モジュールタイプ名", ... }`
  - 例: `"top-9": { type: "new_puzzle", action: "clickNew" }`

**確認ポイント:**
- `type` は後で `puzzleMap` に登録する名前と一致させる
- 必要に応じて `action`, `variant`, `label` などの追加プロパティを定義

---

### 2. パズルファイルの作成 (`js/puzzles/新規ファイル.js`)

- [ ] 新規JavaScriptファイルを作成（例: `new_puzzle.js`）

**必須実装関数:**

#### `render(config, gameStateRef)`
- [ ] HTML文字列を返す関数を実装
- [ ] `config` から必要な設定を取得して使用
- [ ] 必要に応じて `gameStateRef` から状態を参照
- [ ] ユニークなIDを持つ要素を作成（複数レーンで使用する場合の競合回避）

**例:**
```javascript
export function render(config, gameStateRef) {
  return `
    <div class="new-puzzle-module" id="new-puzzle-${config.tier}-${config.index}">
      <button data-action="${config.action}">CLICK</button>
    </div>
  `;
}
```

#### `handleAction(action, config, tier, index, element, gameState, showModal, triggerMorseVibration)`
- [ ] アクション処理関数を実装
- [ ] 処理した場合は `true`、未処理の場合は `false` を返す
- [ ] 必要に応じて `gameState` を更新
- [ ] クリア条件を満たした場合は `gameState` にフラグを設定
- [ ] クリア時は効果音を再生（`ac.wav`）

**例:**
```javascript
export function handleAction(action, config, tier, index, element, gameState, showModal, triggerMorseVibration) {
  if (action === "clickNew") {
    // 処理ロジック
    if (/* クリア条件 */) {
      gameState.isNewPuzzleCleared = true;
      const audio = new Audio("ac.wav");
      audio.volume = 0.5;
      audio.play().catch(err => console.log("Audio play failed:", err));
    }
    return true;
  }
  return false;
}
```

**オプション実装関数（必要に応じて）:**

#### 初期化関数（例: `initNewPuzzle(gameState)`）
- [ ] カメラ、マイク、物理エンジンなどのリソースを初期化
- [ ] `main.js` の `IntersectionObserver` から呼び出される想定
- [ ] 既に初期化済みの場合は早期リターン

#### 停止関数（例: `stopNewPuzzle()`）
- [ ] リソースをクリーンアップ（ストリーム停止、インターバルクリアなど）
- [ ] `main.js` の `IntersectionObserver` から呼び出される想定

---

### 3. モジュールマッピングの追加 (`js/modules.js`)

- [ ] パズルファイルをインポート
  ```javascript
  import * as newPuzzle from "./puzzles/new_puzzle.js";
  ```

- [ ] `puzzleMap` オブジェクトにエントリを追加
  ```javascript
  const puzzleMap = {
    // ...
    new_puzzle: newPuzzle,  // config.jsのtypeと一致させる
  };
  ```

**確認ポイント:**
- `config.js` の `type` と `puzzleMap` のキーが一致しているか
- インポートパスが正しいか

---

### 4. CSSファイルの作成 (`css/puzzles/新規ファイル.css`)

- [ ] 新規CSSファイルを作成（例: `new_puzzle.css`）
- [ ] モジュール固有のスタイルを定義
- [ ] クラス名は他のモジュールと競合しないように命名

**確認ポイント:**
- レスポンシブデザインを考慮
- タッチ操作を考慮（`-webkit-tap-highlight-color: transparent` など）
- ダークテーマに適合した色を使用

---

### 5. CSSインポートの追加 (`css/modules.css`)

- [ ] `@import url("puzzles/新規ファイル.css");` を追加

**確認ポイント:**
- インポート順序が適切か（依存関係がある場合）
- パスが正しいか

---

### 6. メインループへの統合 (`js/main.js`)

**モジュールが表示/非表示時に処理が必要な場合:**

- [ ] `IntersectionObserver` のコールバック内に処理を追加

**表示時（`entry.isIntersecting === true`）:**
```javascript
if (tier === "top" && index === 9) {
  setTimeout(() => {
    newPuzzle.initNewPuzzle(gameState);
  }, 100);
}
```

**非表示時（`entry.isIntersecting === false`）:**
```javascript
if (tier === "top" && index === 9) {
  newPuzzle.stopNewPuzzle();
}
```

**定期的な更新が必要な場合:**

- [ ] `setInterval` を追加（例: 物理演算の更新、センサー値の監視）
```javascript
setInterval(() => {
  if (gameState.activeIndices.top === 9) {
    newPuzzle.updateLogic(gameState);
  }
}, 16); // 約60fps
```

**確認ポイント:**
- パフォーマンスを考慮（不要な処理は実行しない）
- リソースリークを防ぐ（適切なクリーンアップ）

---

### 7. ゲーム状態の追加 (`js/main.js`)

- [ ] `gameState` オブジェクトに新規フラグを追加（クリア状態など）
  ```javascript
  const gameState = {
    // ...
    isNewPuzzleCleared: false,
  };
  ```

**確認ポイント:**
- フラグ名は明確で一意であること
- 実績システムで使用する場合は `achievements.js` も更新

---

### 8. 実績システムへの追加（必要に応じて）(`js/achievements.js`)

- [ ] `ACHIEVEMENTS` 配列に新規実績を追加
  ```javascript
  {
    id: "new_puzzle",
    name: "ACHIEVEMENT NAME",
    module: "TOP-9",
    flavor: "実績の説明文...",
    flag: "isNewPuzzleCleared"  // gameStateのフラグ名と一致
  }
  ```

**確認ポイント:**
- `flag` は `gameState` のフラグ名と一致しているか
- `module` は正しいモジュールIDを記載しているか

---

## 🔍 実装パターン別チェックリスト

### パターンA: シンプルなボタン/パネルモジュール

- [ ] `render()` でHTMLを返す
- [ ] `handleAction()` でクリック処理
- [ ] CSSでスタイリング
- [ ] 追加の初期化/停止処理は不要

**例:** `rgb_button.js`, `system.js`, `clipboard.js`

---

### パターンB: センサー/カメラ/マイクを使用するモジュール

- [ ] 初期化関数を実装（リソース取得）
- [ ] 停止関数を実装（リソース解放）
- [ ] `main.js` の `IntersectionObserver` に統合
- [ ] 権限要求の処理（必要に応じて `permissions.js` を参照）

**例:** `face_camera.js`, `color_camera.js`, `audio_level.js`

**注意事項:**
- カメラ/マイクは表示時のみ起動し、非表示時に停止すること
- エラーハンドリングを適切に実装
- タイムアウト処理を考慮

---

### パターンC: 物理演算/アニメーションを使用するモジュール

- [ ] 初期化関数でエンジンをセットアップ
- [ ] 更新関数を実装（`main.js` の `setInterval` から呼び出し）
- [ ] 停止関数でレンダリングを停止（データは保持）
- [ ] 再開関数を実装（表示時に再開）

**例:** `ball_monitor.js`

**注意事項:**
- パフォーマンスを考慮（非表示時は更新を停止）
- リソースリークを防ぐ（適切なクリーンアップ）

---

### パターンD: 複数モジュール間で連携するモジュール

- [ ] `gameState` を介して状態を共有
- [ ] 他のモジュールの状態を監視
- [ ] タイミングを考慮した実装

**例:** 
- `cable_socket.js` + `monitor.js`（ケーブル接続監視）
- `ball_monitor.js` + `rainbow_screen.js`（壁の位置連携）
- `lock_mechanism.js`（中段と下段の同期）

---

## 🐛 デバッグチェックリスト

- [ ] ブラウザのコンソールでエラーが出ていないか確認
- [ ] モジュールが正しく表示されるか確認
- [ ] クリック/タッチ操作が正しく動作するか確認
- [ ] モジュールが非表示になった時にリソースが解放されるか確認
- [ ] 複数回表示/非表示を繰り返しても問題ないか確認
- [ ] モバイルデバイスで動作確認（必要に応じて）
- [ ] 実績が正しく解除されるか確認（実績を追加した場合）

---

## 📝 命名規則

### ファイル名
- JavaScript: `スネークケース.js`（例: `new_puzzle.js`）
- CSS: `スネークケース.css`（例: `new_puzzle.css`）

### 関数名
- `render()`: 固定
- `handleAction()`: 固定
- 初期化関数: `init + モジュール名`（例: `initNewPuzzle`）
- 停止関数: `stop + モジュール名`（例: `stopNewPuzzle`）

### クラス名
- CSSクラス: `ケバブケース`（例: `new-puzzle-module`）
- ID: `ケバブケース`（例: `new-puzzle-top-9`）

### ゲーム状態フラグ
- `is + モジュール名 + Cleared`（例: `isNewPuzzleCleared`）

---

## 🎯 よくあるミスと対策

### ❌ モジュールが表示されない
- `config.js` に定義を追加したか確認
- `modules.js` の `puzzleMap` に登録したか確認
- `render()` 関数が正しく実装されているか確認

### ❌ クリックが反応しない
- `data-action` 属性が正しく設定されているか確認
- `handleAction()` が `true` を返しているか確認
- イベント委譲が正しく動作しているか確認（`main.js` の `lane.addEventListener("click")`）

### ❌ リソースリークが発生する
- 非表示時に適切にクリーンアップしているか確認
- `setInterval` を `clearInterval` で停止しているか確認
- ストリームを `getTracks().forEach(track => track.stop())` で停止しているか確認

### ❌ モジュール間で状態が共有されない
- `gameState` を介して状態を共有しているか確認
- フラグ名が一意であるか確認

### ❌ 実績が解除されない
- `gameState` のフラグ名が `achievements.js` の `flag` と一致しているか確認
- フラグが正しく設定されているか確認（`gameState.isNewPuzzleCleared = true`）

---

## 📚 参考実装

### シンプルな実装例
- `rgb_button.js` - 基本的なボタン
- `system.js` - システムメニュー
- `audio_level.js` - センサーモニター

### 中程度の実装例
- `clipboard.js` - クリップボード操作
- `lock_mechanism.js` - 状態管理とUI更新
- `face_camera.js` - カメラとAI検出

### 複雑な実装例
- `ball_monitor.js` - 物理演算エンジン
- `color_camera.js` - カメラと色判定
- `cable_socket.js` + `monitor.js` - モジュール間連携

---

## ✅ 最終確認

新規モジュールを追加した後、以下を確認してください:

1. [ ] すべてのファイルが正しく作成・編集されている
2. [ ] ブラウザでエラーなく動作する
3. [ ] モジュールが正しく表示される
4. [ ] インタラクションが正しく動作する
5. [ ] リソースが適切に管理されている（メモリリークなし）
6. [ ] 実績が正しく解除される（実績を追加した場合）
7. [ ] モバイルデバイスで動作確認（必要に応じて）

---

**作成日:** 2024年
**最終更新:** 2024年
